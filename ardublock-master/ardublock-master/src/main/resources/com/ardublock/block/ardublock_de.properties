
###############
#  ARDUBLOCK  #
###############

#FILE
#****************************
ardublock.file.suffix=Ardublock Programmdatei (*.abp)

#UI
#****************************
ardublock.ui.new=Neu
ardublock.ui.save=Speichern
ardublock.ui.saveAs=Speichern unter
ardublock.ui.load=\u00d6ffnen
ardublock.ui.upload=Hochladen auf den Arduino
ardublock.ui.clone=klonen
ardublock.ui.add_comment=Kommentar hinzuf\u00fcgen
ardublock.ui.delete_comment=Kommentar l\u00f6schen
ardublock.ui.organize_blocks=Alle Bl\u00f6cke neu anordnen
ardublock.ui.create_refer=Verweis erstellen
ardublock.ui.website=letsgoING Projekt
ardublock.ui.website.domain=http://letsgoing.de
ardublock.ui.lmssite=Online Lernen
ardublock.ui.lmssite.domain=http://learn.letsgoing.org
ardublock.ui.blockReference=Block Referenz
ardublock.ui.blockReference.domain=http://blockreference.letsgoing.org
ardublock.ui.modeButton.modeExpert = Experten Bl\u00f6cke
ardublock.ui.modeButton.modeStandard = Standard Bl\u00f6cke
ardublock.ui.serialMonitor=Serieller Monitor
ardublock.ui.saveImage=Bild speichern...
ardublock.ui.version=Version 2.03

#ERROR
#****************************
ardublock.error_msg.unset_variable=Die Variable ist unbestimmt. Bevor die Variable lesend verwendet werden kann, muss ihr ein Wert zugewiesen werden.
ardublock.error_msg.digital_var_slot=Der 'Variable'-Sockel ben\u00f6tigt einen 'digitale_Variable'-Block.\nTIPP: Schaue an dem 'Variable' Sockel an dem hervorgehobenen Block!
ardublock.error_msg.number_local_var_slot=Der 'Variable'-Sockel ben\u00f6tigt einen 'lokale_analoge_Variable'-Block.\nTIPP: Schaue an dem 'Variable' Sockel an dem hervorgehobenen Block!
ardublock.error_msg.number_var_slot= Der 'Variable'-Sockel ben\u00f6tigt einen 'analoge_Variable'-Block.\nTIPP: Schaue an dem 'Variable' Sockel an dem hervorgehobenen Block!
ardublock.error_msg.number_slot= Der Sockel ben\u00f6tigt einen 'analoge_Variable'-Block oder einen "Analoger Wert"-Block.\nTIPP: Schaue an dem 'Variable' Sockel an dem hervorgehobenen Block!
ardublock.error_msg.long_number_var_slot=Der 'Variable'-Sockel ben\u00f6tigt einen 'Name_der_langen_analogen_Variable'-Block.\nTIPP: Schaue an dem 'Variable' Sockel an dem hervorgehobenen Block!
ardublock.error_msg.double_number_var_slot=Der 'Variable'-Sockel ben\u00f6tigt einen 'Name_der_dezimalen_analogen_Variable'-Block.\nTIPP: Schaue an dem 'Variable' Sockel an dem hervorgehobenen Block!
ardublock.error_msg.char_var_slot=Der 'Variable'-Sockel ben\u00f6tigt einen 'Name_der_Zeichen_Variable'-Block.\nTIPP: Schaue an dem 'Variable' Sockel an dem hervorgehobenen Block!
ardublock.error_msg.array_var_slot=Der 'Variable'-Sockel ben\u00f6tigt einen 'Name_der_Tabelle'-Block.\nTIPP: Schaue an dem 'Variable' Sockel an dem hervorgehobenen Block!
ardublock.error_msg.number_const_write=Eine Konstante kann nicht mit einem neuen Wert beschrieben werden. Verwende den \"Setze Variable"-Block nur einmal für jede Konstante!
ardublock.error_msg.array_size_slot=Der 'Gr\u00f6ße' Slot muss einen analogen Wert enthalten
ardublock.error_msg.string_var_slot=Der 'Variable'-Slot ben\u00f6tigt einen 'Name_der_String_Variable'-Block.\nTIPP: Schaue an dem 'Variable' Sockel an dem hervorgehobenen Block!
ardublock.error_msg.string_slot= Der 'Wert'-Slot ben\u00f6tigt einen 'String_Variable'-Block oder einen 'Name_der_String_Variable'-Block.\nTIPP: Schaue an dem 'Variable' Sockel an dem hervorgehobenen Block!
ardublock.error_msg.Digital_pin_slot=Pin# muss einer Pin-Nummer des Arduino-Boards entsprechen
ardublock.error_msg.Analog_pin_slot=Pin# muss einer analogen Pin-Nummer des Arduino-Boards entsprechen

ardublock.error_msg.stepper_duplicated=Es gibt schon einen Stepper mit diesem Namen
ardublock.error_msg.stepper_not_existing=Es gibt keinen Stepper mit diesem Namen
 
#TRANSLATOR
#****************************
ardublock.translator.exception.subroutineNameDuplicated=Zwei oder mehr Unterprogramme haben den selben Namen!
ardublock.translator.exception.noLoopFound=Keine Hauptschleife gefunden\!
ardublock.translator.exception.multipleLoopFound=Mehrere Hauptschleifen gefunden\!
ardublock.translator.exception.socketNull=Ein ben\u00f6tigter Wert, Variablenname oder eine Bedingung fehlt!\nTIPP: Suche nach einem leeren Sockel an dem hervorgehobenen Block!
ardublock.translator.exception.subroutineNotDeclared=Unterprogramm nicht deklariert!

#MESSAGE
#****************************
message.title.error=Fehler
message.title.question=Frage
message.content.open_unsaved=Das Ardublock-Programm hat sich ge\u00e4ndert, soll es gespeichert werden?
message.content.overwrite=Soll das vorhandene Programm \u00fcberschrieben werden?
message.file_not_found=Datei wurde nicht gefunden oder der Zugriff wurde verweigert.
message.question.newfile_on_workspace_changed=Das Programm hat sich ge\u00e4ndert, soll eine neue Ardublock-Datei erstellt werden?

##################
#  BLOCK CONFIG  #
##################

#COMMON
#****************************
bg.dummy=Dummy
bg.dummy.description=Dummy Beschreibung

bc.commands=Befehle
bc.pin_number=Pin
bc.pwm_pin_number=~Pin
bc.value=Wert
bc.variable=Variable

#CONTROL
#****************************
bd.control=Steuerung

bg.loop=wiederhole fortlaufend
#legacy support
bg.loop1=wiederhole fortlaufend
bg.loop1.description=Hauptschleife loop()
bg.loop2=wiederhole fortlaufend
bg.loop2.description=Hauptschleife loop()
bg.loop3=wiederhole fortlaufend
bg.loop3.description=Hauptschleife loop()
#End of legacy support
bg.program=Programm
bg.setup=Setup
bg.if=falls
bg.ifelse=falls/sonst
bg.repeat_times=wiederhole
bg.repeat=wiederhole und zaehle
bg.break=unterbreche
bg.delay=warte Millisekunden
bg.delay_microseconds=warte Microsekunden
bg.subroutine=Unterprogramm
bg.subroutine-ref=Unterprogramm
bg.subroutine_var=UP_mit_Parametern
bg.subroutine-ref_var=UP_mit_Parametern
bg.ref_var=Uebergabe_Variable
bg.while=solange
bg.do_while=mache solange
bg.interrupt=interrupt
bg.wait=solange (millis)


bg.program.description=Schleife und Setup
bg.loop.description=Schleife mit automatischem Setup
bg.delay.description=Warte Millisekunden. Solange tut das Programm nichts
bg.if.description=F\u00fchre Befehle aus, wenn die Bedingung WAHR ist
bg.ifelse.description=F\u00fchre die ersten Befehle aus wenn die Bedingung WAHR ist, sonst die zweiten
bg.while.description=F\u00fchre Befehle aus, solange die Bedingung WAHR ist
bg.do_while.description=F\u00fchre Befehle aus, solange die Bedingung WAHR ist
bg.repeat_times.description=Wiederhole die Befehle x-mal
bg.repeat.description=Wiederhole die Befehle x-mal. Die Wiederholungen werden in der Variable gespeichert
bg.break.description=Beende die aktuelle Schleife\nACHTUNG: Nicht in der Hauptschleife verwenden!
bg.subroutine.description=Erstellt ein Unterprogramm.\nDas Unterprogramm muss im Hauptprogramm aufgerufen werden
bg.subroutine-ref.description=Ruft das Unterprogramm mit gleichem Namen auf
bg.subroutine_var.description=Erstellt ein Unterprogramm mit \u00dcbergabe- und  R\u00fcckgabewert
bg.subroutine-ref_var.description=Ruft das Unterprogramm mit gleichem Namen auf.\n Gibt den R\u00fcckgabewert vom Unterprogramm aus und übergibt den \u00dcbergabewert
bg.delay_microseconds.description=Warte Mikrosekunden. Solange tut das Programm nichts
bg.interrupt.description=Interrupt-Block\nIR-Nr.0 = Pin2\nIR-Nr.1 = Pin3\n\nIR-Mode\n0: LOW\n1: HIGH\n2: RISING\n3: FALLING\n4: CHANGE\n
bg.wait.description=Befehle ausserhalb von mache werden nur alle x-Millisekunden ausgef\u00fchrt\nDie Startzeit jedes Durchgangs wird in der Variable gespeichert 
bg.repeat_control.description=

bc.setup=Setup
bc.loop=Loop
bc.loop.description = Liste mit Befehlen die fotlaufen wiederholt wird.

bc.do=mache
bc.var=Name der Iterationsvariable
bc.microseconds=Microsekunden
bc.milliseconds=Millisekunden
bc.transmit=\u00fcbertrage
bc.repeat_times=mal
bc.test=teste
bc.then=dann
bc.else=sonst
bc.condition=teste
bc.start=start
bc.end=stop
bc.increment=Schritte von
bc.time=Millisekunden
bc.sub_var = \u00dcbergabewert
bc.sub_return = R\u00fcckgabewert
bc.irName = ISR Name
bc.irNumber = IR Nummer
bc.irType = IR Modus

#OUTPUT
#****************************
bd.output=Output

bg.pin-write-analog=analogWrite
bg.pin-write-digital=digitalWrite
bg.servo_default=Servo
bg.tone=Ton
bg.tone_time=Ton
bg.no_tone=kein Ton
bg.attach_servo_default=Servo verbinden
bg.detach_servo_default=Servo trennen 

bg.neopixel_init=Setup Pixel 
bg.neopixel_pixel_color=Farbe fuer Pixel RGB [0...255]
bg.neopixel_show= Daten an Pixel senden
bg.neopixel_brightness=Pixel Helligkeit[0...255]
bg.stepper_2pin=Setup f\u00fcr Stepper
bg.stepper_4pin=Setup f\u00fcr Stepper
bg.stepper_set_rpm=Stepper U/min
bg.stepper_steps=Stepper Schritte

bg.attach_servo_default.description=Servo verbinden
bg.detach_servo_default.description=Servo trennen
bg.servo_default.description=Steuere einen Servo an
bg.stepper_2pin.description=Setup f\u00fcr einen Schrittmotor mit 2-Pin-Ansteuerung
bg.stepper_4pin.description=Setup f\u00fcr einen Schrittmotor mit 4-Pin-Ansteuerung
bg.stepper_set_rpm.description=Setze Geschwindigkeit f\u00fcr Schrittmotor (Umdrehungen pro Minute)
bg.stepper_steps.description=Bewege Schrittmotor X Schritte
bg.tone.description=Generiert ein Rechtecksignal mit der angegebenen Frequenz(und 50 % Tastverh\u00e4ltnis) auf dem Pin.
bg.tone_time.description=Generiert ein Rechtecksignal f\u00fcr eine bestimmte Zeit mit der angegebenen Frequenz(und 50 % Tastverh\u00e4ltnis) auf dem Pin.
bg.no_tone.description=Beendet das Rechtecksignals das durch tone() ausgel\u00f6st wurde.
bg.pin-write-digital.description=Ausgangwert f\u00fcr digitalen Pin festlegen [HIGH / LOW]
bg.pin-write-analog.description=PWM-Ausgang erh\u00e4lt Wert [0-255]
bg.neopixel_brightness.description=Stellt die Helligkeit der gesamten Kette ein
bg.neopixel_pixel_color.description=Farbewerte fuer einen bestimmten Pixel festlegen
bg.neopixel_init.description=Initialisiert die RGB-Pixel\nSchnittstelle: NEO_KHZ800 / NEO_KHZ400\nFarbfolge: NEO_GRB / NEO_RGB
bg.neopixel_show.description=Daten werden erst mit diesem Befehl an die Pixel \u00fcbertragen

bc.steps=Schritte/U
bc.speed=U/min
bc.red=Rot Start
bc.blue=Blau Start
bc.green=Gr\u00fcn Start
bc.brightness=Helligkeit
bc.Nb_of_Led=Wie viele Pixel
bc.Nb_of_Led.description=Wie viele Pixel hat die Kette
bc.Pixel_Nb=Nummer Pixel
bc.Pixel_Nb.description=Welches Pixel soll programmiert werden (beginnend mit 0)
bc.schnittstelle=Schnittstelle
bc.farbfolge=Farbfolge
bc.angle=Winkel
bc.frequency =Frequenz


#INPUT
#****************************
bd.input=Input

bg.pin-read-analog=analogRead
bg.pin-read-digital=digitalRead
bg.pin-read-digital-pullup=inputPullup
bg.LGI_Ultrasonic=Wert Ultraschall Sensor

bg.LGI_Qtouch_Init1=Setup fuer Q-Touch-Button1
bg.LGI_Qtouch_Init2=Setup fuer Q-Touch-Button2
bg.LGI_Qtouch_Init3=Setup fuer Q-Touch-Button3
bg.LGI_Qtouch_Button1_getOffset=Offset von Q-Touch-Button1
bg.LGI_Qtouch_Button2_getOffset=Offset von Q-Touch-Button2
bg.LGI_Qtouch_Button3_getOffset=Offset von Q-Touch-Button3
bg.LGI_Qtouch_Button1_getRaw=Raw-Wert von Q-Touch-Button1
bg.LGI_Qtouch_Button2_getRaw=Raw-Wert von Q-Touch-Button2
bg.LGI_Qtouch_Button3_getRaw=Raw-Wert von Q-Touch-Button3
bg.LGI_Qtouch_Button1_isTouched=Q-Touch-Button1 beruehrt?
bg.LGI_Qtouch_Button2_isTouched=Q-Touch-Button2 beruehrt?
bg.LGI_Qtouch_Button3_isTouched=Q-Touch-Button3 beruehrt?
bg.LGI_Qtouch_Slider_Init=Q-Touch-Slider Setup
bg.LGI_Qtouch_Slider_getTouchPosition=Wert von Q-Touch-Slider
bg.LGI_Qtouch_Slider_getOffset1=Offset1 von Q-Touch-Slider
bg.LGI_Qtouch_Slider_getOffset2=Offset2 von Q-Touch-Slider
bg.LGI_Qtouch_Slider_getOffset3=Offset3 von Q-Touch-Slider

bg.pin-read-analog.description=Liest den analogen Wert vom Pin. 0V = 0. 5V = 1023
bg.pin-read-digital.description=Liest den digitalen Wert vom Pin ein (HIGH or LOW)
bg.pin-read-digital-pullup.description=Setzt den Pin auf Eingang mit einem Pullup-Widerstand\n Gibt HIGH zurück, wenn nichts angeschlossen ist
bg.LGI_Ultrasonic.description=Lese Messwert vom Unltraschallsensor
bg.LGI_Qtouch_Init1.description=Setup fuer Q-Touch-Button1
bg.LGI_Qtouch_Init2.description=Setup fuer Q-Touch-Button2
bg.LGI_Qtouch_Init3.description=Setup fuer Q-Touch-Button3
bg.LGI_Qtouch_Button1_getOffset.description=Gibt den für den Nullabgleich verwendeten Wert zur\u00fcck
bg.LGI_Qtouch_Button2_getOffset.description=Gibt den für den Nullabgleich verwendeten Wert zur\u00fcck
bg.LGI_Qtouch_Button3_getOffset.description=Gibt den für den Nullabgleich verwendeten Wert zur\u00fcck
bg.LGI_Qtouch_Button1_getRaw.description=Gibt den gemessenen, analogen Wert zur\u00fcck
bg.LGI_Qtouch_Button2_getRaw.description=Gibt den gemessenen, analogen Wert zur\u00fcck
bg.LGI_Qtouch_Button3_getRaw.description=Gibt den gemessenen, analogen Wert zur\u00fcck
bg.LGI_Qtouch_Button1_isTouched.description=Gibt WAHR zur\u00fcck, wenn Button1 ber\u00fchrt wird
bg.LGI_Qtouch_Button2_isTouched.description=Gibt WAHR zur\u00fcck, wenn Button2 ber\u00fchrt wird
bg.LGI_Qtouch_Button3_isTouched.description=Gibt WAHR zur\u00fcck, wenn Button3 ber\u00fchrt wird
bg.LGI_Qtouch_Slider_Init.description=QTouch-Slider initialisieren
bg.LGI_Qtouch_Slider_getTouchPosition.description=Gibt die Position vom Q-Touch-Slider zurück [0...100]
bg.LGI_Qtouch_Slider_getOffset1.description=Ermittelt den Offset vom ersten Slider-Element
bg.LGI_Qtouch_Slider_getOffset2.description=Ermittelt den Offset vom zweiten Slider-Element
bg.LGI_Qtouch_Slider_getOffset3.description=Ermittelt den Offset vom dritten Slider-Element

bc.analogpin_number=#AnalogPin

#LOGIC
#****************************
bd.logic=Log. Operatoren
#bd.logic=Tests

bg.not_equal_poly= !=
bg.equal_poly= ==
bg.equal_digital===
bg.not_equal_digital=!=
bg.greater=>
bg.greater_equal=>=
bg.less=<
bg.less_equal=<=
bg.not=NICHT
bg.not_equal=!=
bg.and=UND
bg.or=ODER
bg.equal_digital===
bg.not_equal_digital=!=
bg.bit_and=&
bg.bit_or=|
bg.bit_xor=^
bg.bit_not=~
bg.bit_shift_left=<<
bg.bit_shift_right=>>

bg.greater.description=WAHR, wenn der erste Wert gr\u00f6ßer als der Zweite ist
bg.less.description=WAHR, wenn der erste Wert kleiner als der Zweite ist
bg.equal.description=WAHR, wenn beide analogen Werte identisch sind
bg.equal_digital.description=WAHR, wenn beide digitalen Werte identisch sind
bg.greater_equal.description=WAHR, wenn der erste Wert gr\u00f6ßer oder gleich dem Zweiten ist
bg.less_equal.description=WAHR, wenn der erste Wert kleiner oder gleich dem Zweiten ist
bg.not_equal.description=WAHR, wenn NICHT beide analogen Werte identisch sind
bg.not_equal_digital.description=WAHR, wenn NICHT beide digitalen Werte identisch sind
bg.and.description=WAHR, wenn beide beide Bedingungen erf\u00fcllt sind.
bg.or.description=WAHR, wenn eine oder beide Bedingungen erf\u00fcllt sind.
bg.not.description= Das Gegenteil von (z.B. WAHR wird zu FALSCH)
bg.equal_poly.description=WAHR wenn die zwei Zeichen identisch sind
bg.not_equal_poly.description=WAHR wenn die zwei Zeichen NICHT identisch sind
bg.bit_and.description=bitweises UND
bg.bit_or.description=bitweises ODER
bg.bit_xor.description=bitweises EXCLUSIV-ODER
bg.bit_not.description=bitweises NICHT
bg.bit_shift_left.description=verschiebe Bits nach links
bg.bit_shift_right.description=verschiebe Bits nach rechts

#OPERATORS
#****************************
bd.operators=Math. Operatoren

bg.constrain=einschr\u00e4nken
bg.abs=abs
bg.addition=+
bg.cos=cos
bg.division=\u00f7
bg.equal===
bg.map=zuordnen
bg.map_common=map [0, 1023] to [0, 255]
bg.max=max
bg.min=min
bg.modulo=%
bg.multiplication=x
bg.pow=Potenz
bg.random=Zufallszahl
bg.random_range=Zufallszahl
bg.sin=sin
bg.sqrt=Wurzel
bg.subtraction=-
bg.tan=tan

bg.addition.description=Summe zweier Zahlen
bg.subtraction.description=Differenz zweier Zahlen
bg.multiplication.description=Produkt zweier Zahlen
bg.division.description=Quotient zweier Zahlen
bg.random.description=Erzeuge Zufallszahl zwischen "0" und "max-1"
bg.map_common.description=Ordne die Werte von [0, 1023] zu den Werten von [0, 255]
bg.map.description=Ordne Werte vom Bereich "von" zum Bereich "zu"
bg.constrain.description=Beschr\u00e4nke eine analoge Zahl auf einen Bereich
bg.random_range.description=Erzeuge Zufallszahl zwischen "min" und "max-1"


bc.max=max
bc.min=min
bc.to=bis
bc.fromLow= von Low
bc.fromHigh=von High
bc.toLow=nach Low
bc.toHigh=nach High
bc.from=von
bc.base=Basis
bc.exponent=Exponent
bc.low=unterer
bc.high=oberer
bc.element = Element

#CAST
#****************************
bd.cast=Typ Konvertierung

bg.cast_number=wandle in analogen Wert
bg.cast_number_byte=wandle in kurzen analogen Wert
bg.cast_number_long=wandle in langen analogen Wert
bg.cast_number_float=wandle in dezimalen Wert
bg.cast_byte_char=wandle kurzen analoger Wert in Zeichen
bg.cast_char_byte=wandle Zeichen zu kurzem analogen Wert
bg.cast_low_int_char=unterer Teil analoger Wert zu Zeichen
bg.cast_up_int_char=oberer Teil analoger Wert zu Zeichen
bg.cast_char_int=Zeichen zu analoger Wert
bg.cast_byte_int=kurzer analoger Wert zu analogem Wert

bg.toint.description=Zeichen in analogen Wert umwandeln
bg.string_toInt.description=Lese analogen Wert aus Zeichenkette
bg.cast_number.description=wandle in analogen Wert
bg.cast_number_byte.description=wandle in kurzen analogen Wert
bg.cast_number_long.description=wandle in langen analogen Wert
bg.cast_number_float.description=wandle in dezimalen Wert
bg.cast_byte_char.description=wandle analogen Wert zu Zeichen
bg.cast_char_byte.description=wandle Zeichen zu kurzem analogen Wert
bg.cast_low_int_char.description=wandle unteren Teil von analogem Wert zu Zeichen
bg.cast_up_int_char.description=wandle oberen Teil von analogem Wert zu Zeichen
bg.cast_char_int.description=erzeuge analogen Wert aus zwei Zeichen
bg.cast_byte_int.description=erzeuge analogen Wert aus zwei kurzen analogen Werten

bc.lowerByte=unterer Wert
bc.upperByte=oberer Wert

#NUMBERS
#****************************
bd.number=Variablen/Konstanten

bg.millis=Millis
bg.digital-high=HIGH
bg.digital-low=LOW
bg.true=true
bg.false=false

bg.fake=fake
bg.string=ABCD
bg.message_single=ABCD
bg.char=A
bg.number=1
bg.setter_variable_digital=Setze digitale Variable
bg.setter_variable_number=Setze analoge Variable
bg.setter_variable_number_byte=Setze kurze analoge Variable
bg.setter_variable_number_long=Setze lange analoge Variable
bg.setter_variable_number_float=Setze dezimale Variable
bg.setter_variable_char=Setze Zeichen Variable
bg.setter_variable_string=Setze Zeichenkette
bg.variable_digital=digitale_Variable
bg.constant_digital=digitale_Konstante
bg.variable_number=analoge_Variable
bg.constant_number=analoge_Konstante
bg.variable_char=Zeichen_Variable
bg.local_variable_char=lokale_Zeichen_Variable
bg.variable_string=Zeichenketten_Variable
bg.local_variable_string=lokale_Zeichenketten_Variable
bg.local_variable_number=lokale_analoge_Variable
bg.local_variable_digital=lokale_digitale_Variable

bg.millis.description=Gibt die Millisekungen seit Programmstart zur\u00fcck\n(langer analoger Wert)
bg.true.description=digitaler Wert WAHR (true)
bg.false.description=digitaler Wert FALSCH (false)
bg.digital-high.description=Pin HIGH
bg.digital-low.description=Pin LOW
bg.char.description=Ein Zeichen
bg.number.description=Analoger Wert
bg.variable_number.description=Name der analogen Variable\nDatentyp hängt vom \"Setze-Block\" ab
bg.constant_number.description=Name der analogen Konstante\nDie Konstante kann nur einmal gesetzt werden\nDatentyp hängt vom \"Setze-Block\" ab
bg.variable_digital.description=Name der digitalen Variable
bg.constant_digital.description=Name der digitalen Konstante\nDie Konstante kann nur einmal gesetzt werden
bg.variable_string.description=Name der Zeichenketten Variable
bg.local_variable_string.description=Name der Zeichenketten Variable
bg.setter_variable_number.description=Setze eine analoge Variable (int).\n-32,768 bis +32,767
bg.setter_variable_number_byte.description=Setze eine kurze analoge Variable (byte).\n 0 bis 255
bg.setter_variable_number_long.description=Setze eine lange analoge Variable (long). \n-2,147,483,648 bis 2,147,483,647
bg.setter_variable_number_float.description=Setze eine dezimale Variable (float).\n +/- 3.4028235E+38
bg.setter_variable_digital.description=Setze eine digitale Variable (bool).\nHIGH or LOW
bg.setter_variable_string.description=Setze eine Zeichenkette Variable (String)
bg.setter_variable_char.description=Setze Zeichen Variable (char)
bg.variable_char.description=Zeichen Variable (char)
bg.local_variable_char.description=lokale Zeichen Variable (char)
bg.string.description=Zeichenkette (String)
bg.local_variable_number.description=Name der lokalen analogen Variable\nDatentyp hängt vom \"Setze-Block\" ab
bg.local_variable_digital.descriptionName der lokalen digitalen Variable (bool)

bc.string=String
bc.num=#
bc.position=Position
bc.variable_digital=digitale_Variable
bc.variable_number=analoge_Variable
bc.variable_number_long =lange_analogen_Variable
bc.variable_number_float=dezimale_Variable

#ARRAYS
#****************************
bd.array=Tabellen

bg.create_char_array=Erstelle Zeichenkette
bg.read_char_array=lese Zeichen
bg.setter_char_array=setze Zeichen
bg.create_number_array=Erstelle analoge Tabelle
bg.create_number_byte_array=Erstelle kurze analoge Tabelle
bg.create_number_long_array=Erstelle lange analoge Tabelle
bg.create_number_float_array=Erstelle dezimale Tabelle
bg.setter_number_array=Setze Tabellen-Feld
bg.read_number_array=Lese Tabellenelement

bg.create_char_array.description=Erstelle Zeichenkette (char[])
bg.read_char_array.description=lese Zeichen (char) an Position
bg.setter_char_array.description=setze Zeichen (char) an Position
bg.create_number_aray.description=Erzeuge ein Array f\u00fcr analoge Werte (int)\n-32,768 bis +32,767
bg.create_number_byte_array.description=Erzeuge ein Array f\u00fcr kurze analoge Werte (byte)\n 0-255
bg.create_number_long_array.description=Erzeuge ein Array f\u00fcr lange analoge Werte (long)
bg.create_number_float_array.description=Erzeuge ein Array f\u00fcr dezimale Werte (float)
bg.setter_number_array.description=Setze den Wert eines Array-Feldes
bg.read_number_array.description=Lese den Wert eines\nTabellen-Feldes

bc.array=Tabellen-Name
bc.vecsize=Anzahl Werte
bc.number_chars=Anzahl Zeichen


#COMMUNICATION
#****************************
bd.communication=Kommunikation

bg.glue_poly=verbinde
bg.glue_msg=verbinde
bg.glue_sb=verbinde
bg.glue_sn=verbinde
bg.serial_parseInt=Serial parseAnalog
bg.serial_available=Serial available
bg.serial_read=Serial read
bg.serial_print=Serial print
bg.serial_print_baud=Serial print
bg.serial_begin=Serial begin 
bg.soft_serial_begin=softSerial begin 
bg.soft_serial_print=softSerial print
bg.soft_serial_read=softSerial read
bg.soft_serial_available=softSerial available
#bg.serial_println=serial println
bg.serial_write=serial write
bg.serialEvent=serialEvent
bg.glue_digital=verbinde
bg.glue_number=verbinde
bg.glue_char=verbinde
bg.glue_string=verbinde

bg.serial_write.description=Sende Nachricht via Serial
bg.serial_print.description=Sende Nachricht via Serial
bg.serial_read.description=Lese Zeichen via Serial als kurze analoge Variable ein\n(siehe ASCII-Tabelle)
bg.serial_available.description=Daten verf\u00fcgbar an Serial
#bg.serial_println.description=Send message via Serial port with a return
bg.serial_print_baud.description=Sende Nachricht via Serial
bg.serial_begin.description=Starte Serial Schnittstelle mit bestimmter Baudrate 
bg.soft_serial_begin.description=Starte SoftwareSerial Schnittstelle mit bestimmter Baudrat
bg.soft_serial_print.description=Sende Nachricht via Software Serial
bg.soft_serial_read.description=Lese Nachricht via Software Serial
bg.soft_serial_available.description=Daten verf\u00fcgbar an Software Serial
bg.serial_parseInt.description=Lese den nächsten analogen Wert via Serial
bg.glue_sn.description=Verbindet Zahlen mit einer Zeichenkette
bg.glue_sb.description=Verbindet digitale Werte mit einer Zeichenkette
bg.glue_poly.description=Verbindet Zeichen mit einer Zeichenkette
bg.glue_msg.description=Verbinde Zeichenketten miteinander
bg.serialEvent.description=Unterprogramm serialEvent, wird ausgef\u00fchrt wenn Daten an Serial 
bg.glue_digital.description=Verbinde digitalen Wert mit Zeichenkette
bg.glue_number.description=Verbinde analogen Wert mit Zeichenkette
bg.glue_char.description=Verbinde Zeichen mit Zeichenkette
bg.glue_string.description=Verbinde Zeichenkette mit Zeichenkette

bc.print=print
bc.ln=neue Zeile
bc.rx_pin_number=Rx Pin
bc.tx_pin_number=Tx Pin
bc.baudrate=Baud

#STORAGE
#****************************
bd.storage=Speicher

bg.eeprom_read=lese kurzen analogen Wert von EEPROM
bg.eeprom_write=schreibe kurzen analogen Wert auf EEPROM
bg.eeprom_get=lese beliebigen Datentyp von EEPROM
bg.eeprom_put=schreibe beliebigen Datentyp auf EEPROM
bg.eeprom_length=l\u00e4nge des EEPROM
bg.sd_begin=starte SD
bg.sd_open=öffne Datei SD
bg.sd_close=schließe Datei SD
bg.sd_write=schreibe in Datei SD
bg.sd_read=lese aus Datei SD

bg.eeprom_read.description=lese einen kurzen analogen Wert (0-255) vom EEPROM. Jedes Byte entspicht einer EEPROM Adresse.
bg.eeprom_write.description=schreibe einen kurzen analogen Wert (0-255) auf EEPROM. Jedes Byte entspicht einer EEPROM Adresse.
bg.eeprom_get.description=lese beliebigen Datentyp von EEPROM. Jedes Byte entspicht einer EEPROM Adresse. L\u00e4nge des Datentyps \u00fberprüfen!
bg.eeprom_put.description=schreibe beliebigen Datentyp auf EEPROM. Jedes Byte entspicht einer EEPROM Adresse. L\u00e4nge des Datentyps \u00fberprüfen!
bg.eeprom_length.description=l\u00e4nge des EEPROM
bg.sd_begin.description=starte SD Karte
bg.sd_open.description=\u00d6ffne Datei auf SD Karte
bg.sd_close.description=schließe Datei auf SD Karte
bg.sd_write.description=schreibe in Datei auf SD Karte
bg.sd_read.description=lese aus Datei auf SD Karte


bc.eeprom_address=Adresse
bc.eeprom_data=Daten
bc.File=Datei
bc.sdFileVar  = Datei-Variable
bc.sdFileName = Datei Name
bc.sdFileMode = Starte am Anfang
bc.sdWriteData= Daten
bc.sdCSPin    = CS

#CODE
#****************************
bd.code=Code Bl\u00f6cke

bg.code_head=Code im Programmkopf
bg.code_setup=Code im Setup
bg.code_loop=Code einf\u00fcgen
bg.code_comment=Kommentar einf\u00fcgen

bg.code_loop.description=Code an dieser Stelle einf\u00fcgen
bg.code_head.description=Codeim Programmkopf einf\u00fcgen
bg.code_setup.description=Code im setup() einf\u00fcgen
bg.code_comment.description=Kommentar im Programm einf\u00fcgen
#****************************